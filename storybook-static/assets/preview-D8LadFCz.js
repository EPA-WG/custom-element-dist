import{i as I,d as p,E as C,t as ae,s as H,R as le}from"./index-CQA5dlr6.js";function ce(e,t){const r=e.emit;if(r._isPiped)return;const s=function(i,...n){return t.emit(i,...n),r.call(this,i,...n)};s._isPiped=!0,e.emit=s}function ue(e){const t=[...e];return Object.freeze(t),t}class he{subscriptions=[];async dispose(){await Promise.all(this.subscriptions.map(t=>t()))}}class de{constructor(t){this.initialHandlers=t,this.handlers=[...t]}handlers;prepend(t){this.handlers.unshift(...t)}reset(t){this.handlers=t.length>0?[...t]:[...this.initialHandlers]}currentHandlers(){return this.handlers}}class pe extends he{handlersController;emitter;publicEmitter;events;constructor(...t){super(),I(this.validateHandlers(t),p.formatMessage("Failed to apply given request handlers: invalid input. Did you forget to spread the request handlers Array?")),this.handlersController=new de(t),this.emitter=new C,this.publicEmitter=new C,ce(this.emitter,this.publicEmitter),this.events=this.createLifeCycleEvents(),this.subscriptions.push(()=>{this.emitter.removeAllListeners(),this.publicEmitter.removeAllListeners()})}validateHandlers(t){return t.every(r=>!Array.isArray(r))}use(...t){I(this.validateHandlers(t),p.formatMessage('Failed to call "use()" with the given request handlers: invalid input. Did you forget to spread the array of request handlers?')),this.handlersController.prepend(t)}restoreHandlers(){this.handlersController.currentHandlers().forEach(t=>{t.isUsed=!1})}resetHandlers(...t){this.handlersController.reset(t)}listHandlers(){return ue(this.handlersController.currentHandlers())}createLifeCycleEvents(){return{on:(...t)=>this.publicEmitter.on(...t),removeListener:(...t)=>this.publicEmitter.removeListener(...t),removeAllListeners:(...t)=>this.publicEmitter.removeAllListeners(...t)}}}var fe=async e=>{try{return{error:null,data:await e().catch(r=>{throw r})}}catch(t){return{error:t,data:null}}};const ge=async({request:e,requestId:t,handlers:r,resolutionContext:s})=>{let o=null,i=null;for(const n of r)if(i=await n.run({request:e,requestId:t,resolutionContext:s}),i!==null&&(o=n),i?.response)break;return o?{handler:o,parsedResult:i?.parsedResult,response:i?.response}:null};async function me(e,t="warn"){const r=new URL(e.url),s=ae(r)+r.search,o=`intercepted a request without a matching request handler:

  • ${e.method} ${s}

If you still wish to intercept this unhandled request, please create a request handler for it.
Read more: https://mswjs.io/docs/getting-started/mocks`;function i(n){switch(n){case"error":throw p.error("Error: %s",o),new Error(p.formatMessage('Cannot bypass a request when using the "error" strategy for the "onUnhandledRequest" option.'));case"warn":{p.warn("Warning: %s",o);break}case"bypass":break;default:throw new Error(p.formatMessage('Failed to react to an unhandled request: unknown strategy "%s". Please provide one of the supported strategies ("bypass", "warn", "error") or a custom callback function as the value of the "onUnhandledRequest" option.',n))}}if(typeof t=="function"){t(e,{warning:i.bind(null,"warn"),error:i.bind(null,"error")});return}r.protocol!=="file:"&&i(t)}function ye(e,t){H.add({...e,url:e.url.toString()},t),H.persist()}async function N(e,t,r,s,o,i){if(o.emit("request:start",{request:e,requestId:t}),e.headers.get("x-msw-intention")==="bypass"){o.emit("request:end",{request:e,requestId:t}),i?.onPassthroughResponse?.(e);return}const n=await fe(()=>ge({request:e,requestId:t,handlers:r,resolutionContext:i?.resolutionContext}));if(n.error)throw o.emit("unhandledException",{error:n.error,request:e,requestId:t}),n.error;if(!n.data){await me(e,s.onUnhandledRequest),o.emit("request:unhandled",{request:e,requestId:t}),o.emit("request:end",{request:e,requestId:t}),i?.onPassthroughResponse?.(e);return}const{response:a}=n.data;if(!a){o.emit("request:end",{request:e,requestId:t}),i?.onPassthroughResponse?.(e);return}if(a.status===302&&a.headers.get("x-msw-intention")==="passthrough"){o.emit("request:end",{request:e,requestId:t}),i?.onPassthroughResponse?.(e);return}ye(e,a),o.emit("request:match",{request:e,requestId:t});const c=n.data,l=i?.transformResponse?.(a)||a;return i?.onMockedResponse?.(l,c),o.emit("request:end",{request:e,requestId:t}),l}function ve(e){return{status:e.status,statusText:e.statusText,headers:Object.fromEntries(e.headers.entries())}}function _(e){return e!=null&&typeof e=="object"&&!Array.isArray(e)}function F(e,t){return Object.entries(t).reduce((r,[s,o])=>{const i=r[s];return Array.isArray(i)&&Array.isArray(o)?(r[s]=i.concat(o),r):_(i)&&_(o)?(r[s]=F(i,o),r):(r[s]=o,r)},Object.assign({},e))}var we={},be=/(%?)(%([sdijo]))/g;function Re(e,t){switch(t){case"s":return e;case"d":case"i":return Number(e);case"j":return JSON.stringify(e);case"o":{if(typeof e=="string")return e;const r=JSON.stringify(e);return r==="{}"||r==="[]"||/^\[object .+?\]$/.test(r)?e:r}}}function E(e,...t){if(t.length===0)return e;let r=0,s=e.replace(be,(o,i,n,a)=>{const c=t[r],l=Re(c,a);return i?o:(r++,l)});return r<t.length&&(s+=` ${t.slice(r).join(" ")}`),s=s.replace(/%{2,2}/g,"%"),s}var Ee=2;function ke(e){if(!e.stack)return;const t=e.stack.split(`
`);t.splice(1,Ee),e.stack=t.join(`
`)}var qe=class extends Error{constructor(e,...t){super(e),this.message=e,this.name="Invariant Violation",this.message=E(e,...t),ke(this)}},v=(e,t,...r)=>{if(!e)throw new qe(t,...r)};v.as=(e,t,r,...s)=>{if(!t){const o=s.length===0?r:E(r,s);let i;try{i=Reflect.construct(e,[o])}catch{i=e(o)}throw i}};function x(){if(typeof navigator<"u"&&navigator.product==="ReactNative")return!0;if(typeof process<"u"){const e=process.type;return e==="renderer"||e==="worker"?!1:!!(process.versions&&process.versions.node)}return!1}var M=async e=>{try{return{error:null,data:await e().catch(r=>{throw r})}}catch(t){return{error:t,data:null}}};function Le(e){return new URL(e,location.href).href}function L(e,t,r){return[e.active,e.installing,e.waiting].filter(n=>n!=null).find(n=>r(n.scriptURL,t))||null}var Se=async(e,t={},r)=>{const s=Le(e),o=await navigator.serviceWorker.getRegistrations().then(a=>a.filter(c=>L(c,s,r)));!navigator.serviceWorker.controller&&o.length>0&&location.reload();const[i]=o;if(i)return i.update().then(()=>[L(i,s,r),i]);const n=await M(async()=>{const a=await navigator.serviceWorker.register(e,t);return[L(a,s,r),a]});if(n.error){if(n.error.message.includes("(404)")){const c=new URL(t?.scope||"/",location.href);throw new Error(p.formatMessage(`Failed to register a Service Worker for scope ('${c.href}') with script ('${s}'): Service Worker script does not exist at the given path.

Did you forget to run "npx msw init <PUBLIC_DIR>"?

Learn more about creating the Service Worker script: https://mswjs.io/docs/cli/init`))}throw new Error(p.formatMessage(`Failed to register the Service Worker:

%s`,n.error.message))}return n.data};function G(e={}){if(e.quiet)return;const t=e.message||"Mocking enabled.";console.groupCollapsed(`%c${p.formatMessage(t)}`,"color:orangered;font-weight:bold;"),console.log("%cDocumentation: %chttps://mswjs.io/docs","font-weight:bold","font-weight:normal"),console.log("Found an issue? https://github.com/mswjs/msw/issues"),e.workerUrl&&console.log("Worker script URL:",e.workerUrl),e.workerScope&&console.log("Worker scope:",e.workerScope),console.groupEnd()}async function Te(e,t){if(e.workerChannel.send("MOCK_ACTIVATE"),await e.events.once("MOCKING_ENABLED"),e.isMockingEnabled){p.warn('Found a redundant "worker.start()" call. Note that starting the worker while mocking is already enabled will have no effect. Consider removing this "worker.start()" call.');return}e.isMockingEnabled=!0,G({quiet:t.quiet,workerScope:e.registration?.scope,workerUrl:e.worker?.scriptURL})}var Pe=class{constructor(e){this.port=e}postMessage(e,...t){const[r,s]=t;this.port.postMessage({type:e,data:r},{transfer:s})}};function xe(e){if(!["HEAD","GET"].includes(e.method))return e.body}function Me(e){return new Request(e.url,{...e,body:xe(e)})}var Ae=(e,t)=>async(r,s)=>{const o=new Pe(r.ports[0]),i=s.payload.id,n=Me(s.payload),a=n.clone(),c=n.clone();le.cache.set(n,c),e.requests.set(i,c);try{await N(n,i,e.getRequestHandlers(),t,e.emitter,{onPassthroughResponse(){o.postMessage("PASSTHROUGH")},async onMockedResponse(l,{handler:h,parsedResult:d}){const u=l.clone(),f=l.clone(),g=ve(l);if(e.supports.readableStreamTransfer){const m=l.body;o.postMessage("MOCK_RESPONSE",{...g,body:m},m?[m]:void 0)}else{const m=l.body===null?null:await u.arrayBuffer();o.postMessage("MOCK_RESPONSE",{...g,body:m})}t.quiet||e.emitter.once("response:mocked",()=>{h.log({request:a,response:f,parsedResult:d})})}})}catch(l){l instanceof Error&&(p.error(`Uncaught exception in the request handler for "%s %s":

%s

This exception has been gracefully handled as a 500 response, however, it's strongly recommended to resolve this error, as it indicates a mistake in your code. If you wish to mock an error response, please see this guide: https://mswjs.io/docs/recipes/mocking-error-responses`,n.method,n.url,l.stack??l),o.postMessage("MOCK_RESPONSE",{status:500,statusText:"Request Handler Error",headers:{"Content-Type":"application/json"},body:JSON.stringify({name:l.name,message:l.message,stack:l.stack})}))}};async function Ie(e){e.workerChannel.send("INTEGRITY_CHECK_REQUEST");const{payload:t}=await e.events.once("INTEGRITY_CHECK_RESPONSE");t.checksum!=="26357c79639bfa20d64c0efca2a87423"&&p.warn(`The currently registered Service Worker has been generated by a different version of MSW (${t.packageVersion}) and may not be fully compatible with the installed version.

It's recommended you update your worker script by running this command:

  • npx msw init <PUBLIC_DIR>

You can also automate this process and make the worker script update automatically upon the library installations. Read more: https://mswjs.io/docs/cli/init.`)}var Ce=new TextEncoder;function He(e){return Ce.encode(e)}function _e(e,t){return new TextDecoder(t).decode(e)}function Oe(e){return e.buffer.slice(e.byteOffset,e.byteOffset+e.byteLength)}var We=new Set([101,103,204,205,304]);function X(e){return We.has(e)}var b=Symbol("isPatchedModule"),je=Object.defineProperty,De=(e,t)=>{for(var r in t)je(e,r,{get:t[r],enumerable:!0})},S={};De(S,{blue:()=>Be,gray:()=>T,green:()=>Ne,red:()=>$e,yellow:()=>Ue});function Ue(e){return`\x1B[33m${e}\x1B[0m`}function Be(e){return`\x1B[34m${e}\x1B[0m`}function T(e){return`\x1B[90m${e}\x1B[0m`}function $e(e){return`\x1B[31m${e}\x1B[0m`}function Ne(e){return`\x1B[32m${e}\x1B[0m`}var q=x(),V=class{constructor(e){this.name=e,this.prefix=`[${this.name}]`;const t=O("DEBUG"),r=O("LOG_LEVEL");t==="1"||t==="true"||typeof t<"u"&&this.name.startsWith(t)?(this.debug=R(r,"debug")?y:this.debug,this.info=R(r,"info")?y:this.info,this.success=R(r,"success")?y:this.success,this.warning=R(r,"warning")?y:this.warning,this.error=R(r,"error")?y:this.error):(this.info=y,this.success=y,this.warning=y,this.error=y,this.only=y)}prefix;extend(e){return new V(`${this.name}:${e}`)}debug(e,...t){this.logEntry({level:"debug",message:T(e),positionals:t,prefix:this.prefix,colors:{prefix:"gray"}})}info(e,...t){this.logEntry({level:"info",message:e,positionals:t,prefix:this.prefix,colors:{prefix:"blue"}});const r=new Fe;return(s,...o)=>{r.measure(),this.logEntry({level:"info",message:`${s} ${T(`${r.deltaTime}ms`)}`,positionals:o,prefix:this.prefix,colors:{prefix:"blue"}})}}success(e,...t){this.logEntry({level:"info",message:e,positionals:t,prefix:`✔ ${this.prefix}`,colors:{timestamp:"green",prefix:"green"}})}warning(e,...t){this.logEntry({level:"warning",message:e,positionals:t,prefix:`⚠ ${this.prefix}`,colors:{timestamp:"yellow",prefix:"yellow"}})}error(e,...t){this.logEntry({level:"error",message:e,positionals:t,prefix:`✖ ${this.prefix}`,colors:{timestamp:"red",prefix:"red"}})}only(e){e()}createEntry(e,t){return{timestamp:new Date,level:e,message:t}}logEntry(e){const{level:t,message:r,prefix:s,colors:o,positionals:i=[]}=e,n=this.createEntry(t,r),a=o?.timestamp||"gray",c=o?.prefix||"gray",l={timestamp:S[a],prefix:S[c]};this.getWriter(t)([l.timestamp(this.formatTimestamp(n.timestamp))].concat(s!=null?l.prefix(s):[]).concat(W(r)).join(" "),...i.map(W))}formatTimestamp(e){return`${e.toLocaleTimeString("en-GB")}:${e.getMilliseconds()}`}getWriter(e){switch(e){case"debug":case"success":case"info":return Ge;case"warning":return Xe;case"error":return Ve}}},Fe=class{startTime;endTime;deltaTime;constructor(){this.startTime=performance.now()}measure(){this.endTime=performance.now();const e=this.endTime-this.startTime;this.deltaTime=e.toFixed(2)}},y=()=>{};function Ge(e,...t){if(q){process.stdout.write(E(e,...t)+`
`);return}console.log(e,...t)}function Xe(e,...t){if(q){process.stderr.write(E(e,...t)+`
`);return}console.warn(e,...t)}function Ve(e,...t){if(q){process.stderr.write(E(e,...t)+`
`);return}console.error(e,...t)}function O(e){return q?we[e]:globalThis[e]?.toString()}function R(e,t){return e!==void 0&&e!==t}function W(e){return typeof e>"u"?"undefined":e===null?"null":typeof e=="string"?e:typeof e=="object"?JSON.stringify(e):e.toString()}var Ke=class extends Error{constructor(e,t,r){super(`Possible EventEmitter memory leak detected. ${r} ${t.toString()} listeners added. Use emitter.setMaxListeners() to increase limit`),this.emitter=e,this.type=t,this.count=r,this.name="MaxListenersExceededWarning"}},K=class{static listenerCount(e,t){return e.listenerCount(t)}constructor(){this.events=new Map,this.maxListeners=K.defaultMaxListeners,this.hasWarnedAboutPotentialMemoryLeak=!1}_emitInternalEvent(e,t,r){this.emit(e,t,r)}_getListeners(e){return Array.prototype.concat.apply([],this.events.get(e))||[]}_removeListener(e,t){const r=e.indexOf(t);return r>-1&&e.splice(r,1),[]}_wrapOnceListener(e,t){const r=(...s)=>(this.removeListener(e,r),t.apply(this,s));return Object.defineProperty(r,"name",{value:t.name}),r}setMaxListeners(e){return this.maxListeners=e,this}getMaxListeners(){return this.maxListeners}eventNames(){return Array.from(this.events.keys())}emit(e,...t){const r=this._getListeners(e);return r.forEach(s=>{s.apply(this,t)}),r.length>0}addListener(e,t){this._emitInternalEvent("newListener",e,t);const r=this._getListeners(e).concat(t);if(this.events.set(e,r),this.maxListeners>0&&this.listenerCount(e)>this.maxListeners&&!this.hasWarnedAboutPotentialMemoryLeak){this.hasWarnedAboutPotentialMemoryLeak=!0;const s=new Ke(this,e,this.listenerCount(e));console.warn(s)}return this}on(e,t){return this.addListener(e,t)}once(e,t){return this.addListener(e,this._wrapOnceListener(e,t))}prependListener(e,t){const r=this._getListeners(e);if(r.length>0){const s=[t].concat(r);this.events.set(e,s)}else this.events.set(e,r.concat(t));return this}prependOnceListener(e,t){return this.prependListener(e,this._wrapOnceListener(e,t))}removeListener(e,t){const r=this._getListeners(e);return r.length>0&&(this._removeListener(r,t),this.events.set(e,r),this._emitInternalEvent("removeListener",e,t)),this}off(e,t){return this.removeListener(e,t)}removeAllListeners(e){return e?this.events.delete(e):this.events.clear(),this}listeners(e){return Array.from(this._getListeners(e))}listenerCount(e){return this._getListeners(e).length}rawListeners(e){return this.listeners(e)}},J=K;J.defaultMaxListeners=10;var Je="x-interceptors-internal-request-id";function j(e){return globalThis[e]||void 0}function ze(e,t){globalThis[e]=t}function Ye(e){delete globalThis[e]}var A=class{constructor(e){this.symbol=e,this.readyState="INACTIVE",this.emitter=new J,this.subscriptions=[],this.logger=new V(e.description),this.emitter.setMaxListeners(0),this.logger.info("constructing the interceptor...")}checkEnvironment(){return!0}apply(){const e=this.logger.extend("apply");if(e.info("applying the interceptor..."),this.readyState==="APPLIED"){e.info("intercepted already applied!");return}if(!this.checkEnvironment()){e.info("the interceptor cannot be applied in this environment!");return}this.readyState="APPLYING";const r=this.getInstance();if(r){e.info("found a running instance, reusing..."),this.on=(s,o)=>(e.info('proxying the "%s" listener',s),r.emitter.addListener(s,o),this.subscriptions.push(()=>{r.emitter.removeListener(s,o),e.info('removed proxied "%s" listener!',s)}),this),this.readyState="APPLIED";return}e.info("no running instance found, setting up a new instance..."),this.setup(),this.setInstance(),this.readyState="APPLIED"}setup(){}on(e,t){const r=this.logger.extend("on");return this.readyState==="DISPOSING"||this.readyState==="DISPOSED"?(r.info("cannot listen to events, already disposed!"),this):(r.info('adding "%s" event listener:',e,t),this.emitter.on(e,t),this)}once(e,t){return this.emitter.once(e,t),this}off(e,t){return this.emitter.off(e,t),this}removeAllListeners(e){return this.emitter.removeAllListeners(e),this}dispose(){const e=this.logger.extend("dispose");if(this.readyState==="DISPOSED"){e.info("cannot dispose, already disposed!");return}if(e.info("disposing the interceptor..."),this.readyState="DISPOSING",!this.getInstance()){e.info("no interceptors running, skipping dispose...");return}if(this.clearInstance(),e.info("global symbol deleted:",j(this.symbol)),this.subscriptions.length>0){e.info("disposing of %d subscriptions...",this.subscriptions.length);for(const t of this.subscriptions)t();this.subscriptions=[],e.info("disposed of all subscriptions!",this.subscriptions.length)}this.emitter.removeAllListeners(),e.info("destroyed the listener!"),this.readyState="DISPOSED"}getInstance(){var e;const t=j(this.symbol);return this.logger.info("retrieved global instance:",(e=t?.constructor)==null?void 0:e.name),t}setInstance(){ze(this.symbol,this),this.logger.info("set global instance!",this.symbol.description)}clearInstance(){Ye(this.symbol),this.logger.info("cleared global instance!",this.symbol.description)}};function z(){return Math.random().toString(16).slice(2)}var P=class extends A{constructor(e){P.symbol=Symbol(e.name),super(P.symbol),this.interceptors=e.interceptors}setup(){const e=this.logger.extend("setup");e.info("applying all %d interceptors...",this.interceptors.length);for(const t of this.interceptors)e.info('applying "%s" interceptor...',t.constructor.name),t.apply(),e.info("adding interceptor dispose subscription"),this.subscriptions.push(()=>t.dispose())}on(e,t){for(const r of this.interceptors)r.on(e,t);return this}once(e,t){for(const r of this.interceptors)r.once(e,t);return this}off(e,t){for(const r of this.interceptors)r.off(e,t);return this}removeAllListeners(e){for(const t of this.interceptors)t.removeAllListeners(e);return this}};function Qe(e){return(t,r)=>{const{payload:s}=r,{requestId:o}=s,i=e.requests.get(o);if(e.requests.delete(o),s.type?.includes("opaque"))return;const n=s.status===0?Response.error():new Response(X(s.status)?null:s.body,s);n.url||Object.defineProperty(n,"url",{value:i.url,enumerable:!0,writable:!1}),e.emitter.emit(s.isMockedResponse?"response:mocked":"response:bypass",{response:n,request:i,requestId:s.requestId})}}function Ze(e,t){!t?.quiet&&!location.href.startsWith(e.scope)&&p.warn(`Cannot intercept requests on this page because it's outside of the worker's scope ("${e.scope}"). If you wish to mock API requests on this page, you must resolve this scope issue.

- (Recommended) Register the worker at the root level ("/") of your application.
- Set the "Service-Worker-Allowed" response header to allow out-of-scope workers.`)}var et=e=>function(r,s){return(async()=>{e.events.removeAllListeners(),e.workerChannel.on("REQUEST",Ae(e,r)),e.workerChannel.on("RESPONSE",Qe(e));const n=await Se(r.serviceWorker.url,r.serviceWorker.options,r.findWorker),[a,c]=n;if(!a){const l=s?.findWorker?p.formatMessage(`Failed to locate the Service Worker registration using a custom "findWorker" predicate.

Please ensure that the custom predicate properly locates the Service Worker registration at "%s".
More details: https://mswjs.io/docs/api/setup-worker/start#findworker
`,r.serviceWorker.url):p.formatMessage(`Failed to locate the Service Worker registration.

This most likely means that the worker script URL "%s" cannot resolve against the actual public hostname (%s). This may happen if your application runs behind a proxy, or has a dynamic hostname.

Please consider using a custom "serviceWorker.url" option to point to the actual worker script location, or a custom "findWorker" option to resolve the Service Worker registration manually. More details: https://mswjs.io/docs/api/setup-worker/start`,r.serviceWorker.url,location.host);throw new Error(l)}return e.worker=a,e.registration=c,e.events.addListener(window,"beforeunload",()=>{a.state!=="redundant"&&e.workerChannel.send("CLIENT_CLOSED"),window.clearInterval(e.keepAliveInterval)}),await Ie(e).catch(l=>{p.error("Error while checking the worker script integrity. Please report this on GitHub (https://github.com/mswjs/msw/issues), including the original error below."),console.error(l)}),e.keepAliveInterval=window.setInterval(()=>e.workerChannel.send("KEEPALIVE_REQUEST"),5e3),Ze(c,e.startOptions),c})().then(async n=>{const a=n.installing||n.waiting;return a&&await new Promise(c=>{a.addEventListener("statechange",()=>{if(a.state==="activated")return c()})}),await Te(e,r).catch(c=>{throw new Error(`Failed to enable mocking: ${c?.message}`)}),n})};function Y(e={}){e.quiet||console.log(`%c${p.formatMessage("Mocking disabled.")}`,"color:orangered;font-weight:bold;")}var tt=e=>function(){if(!e.isMockingEnabled){p.warn('Found a redundant "worker.stop()" call. Note that stopping the worker while mocking already stopped has no effect. Consider removing this "worker.stop()" call.');return}e.workerChannel.send("MOCK_DEACTIVATE"),e.isMockingEnabled=!1,window.clearInterval(e.keepAliveInterval),Y({quiet:e.startOptions?.quiet})},rt={serviceWorker:{url:"/mockServiceWorker.js",options:null},quiet:!1,waitUntilReady:!0,onUnhandledRequest:"warn",findWorker(e,t){return e===t}};function st(){const e=(t,r)=>{e.state="pending",e.resolve=s=>{if(e.state!=="pending")return;e.result=s;const o=i=>(e.state="fulfilled",i);return t(s instanceof Promise?s:Promise.resolve(s).then(o))},e.reject=s=>{if(e.state==="pending")return queueMicrotask(()=>{e.state="rejected"}),r(e.rejectionReason=s)}};return e}var Q=class extends Promise{#e;resolve;reject;constructor(e=null){const t=st();super((r,s)=>{t(r,s),e?.(t.resolve,t.reject)}),this.#e=t,this.resolve=this.#e.resolve,this.reject=this.#e.reject}get state(){return this.#e.state}get rejectionReason(){return this.#e.rejectionReason}then(e,t){return this.#t(super.then(e,t))}catch(e){return this.#t(super.catch(e))}finally(e){return this.#t(super.finally(e))}#t(e){return Object.defineProperties(e,{resolve:{configurable:!0,value:this.resolve},reject:{configurable:!0,value:this.reject}})}},nt=class{constructor(e){this.request=e,this.responsePromise=new Q}respondWith(e){v(this.responsePromise.state==="pending",'Failed to respond to "%s %s" request: the "request" event has already been responded to.',this.request.method,this.request.url),this.responsePromise.resolve(e)}};function Z(e){const t=new nt(e);return Reflect.set(e,"respondWith",t.respondWith.bind(t)),{interactiveRequest:e,requestController:t}}async function ee(e,t,...r){const s=e.listeners(t);if(s.length!==0)for(const o of s)await o.apply(e,r)}function ot(e,t){try{return e[t],!0}catch{return!1}}function it(e){try{return new URL(e),!0}catch{return!1}}var te=class extends A{constructor(){super(te.symbol)}checkEnvironment(){return typeof globalThis<"u"&&typeof globalThis.fetch<"u"}async setup(){const e=globalThis.fetch;v(!e[b],'Failed to patch the "fetch" module: already patched.'),globalThis.fetch=async(t,r)=>{var s;const o=z(),i=typeof t=="string"&&typeof location<"u"&&!it(t)?new URL(t,location.origin):t,n=new Request(i,r);this.logger.info("[%s] %s",n.method,n.url);const{interactiveRequest:a,requestController:c}=Z(n);this.logger.info('emitting the "request" event for %d listener(s)...',this.emitter.listenerCount("request")),this.emitter.once("request",({requestId:f})=>{f===o&&c.responsePromise.state==="pending"&&c.responsePromise.resolve(void 0)}),this.logger.info("awaiting for the mocked response...");const l=a.signal,h=new Q;l&&l.addEventListener("abort",()=>{h.reject(l.reason)},{once:!0});const d=await M(async()=>{const f=ee(this.emitter,"request",{request:a,requestId:o});await Promise.race([h,f,c.responsePromise]),this.logger.info("all request listeners have been resolved!");const g=await c.responsePromise;return this.logger.info("event.respondWith called with:",g),g});if(h.state==="rejected")return Promise.reject(h.rejectionReason);if(d.error)return Promise.reject(D(d.error));const u=d.data;if(u&&!((s=n.signal)!=null&&s.aborted)){if(this.logger.info("received mocked response:",u),ot(u,"type")&&u.type==="error")return this.logger.info("received a network error response, rejecting the request promise..."),Promise.reject(D(u));const f=u.clone();return this.emitter.emit("response",{response:f,isMockedResponse:!0,request:a,requestId:o}),Object.defineProperty(u,"url",{writable:!1,enumerable:!0,configurable:!1,value:n.url}),u}return this.logger.info("no mocked response received!"),e(n).then(f=>{const g=f.clone();return this.logger.info("original fetch performed",g),this.emitter.emit("response",{response:g,isMockedResponse:!1,request:a,requestId:o}),f})},Object.defineProperty(globalThis.fetch,b,{enumerable:!0,configurable:!0,value:!0}),this.subscriptions.push(()=>{Object.defineProperty(globalThis.fetch,b,{value:void 0}),globalThis.fetch=e,this.logger.info('restored native "globalThis.fetch"!',globalThis.fetch.name)})}},re=te;re.symbol=Symbol("fetch");function D(e){return Object.assign(new TypeError("Failed to fetch"),{cause:e})}function at(e,t){const r=new Uint8Array(e.byteLength+t.byteLength);return r.set(e,0),r.set(t,e.byteLength),r}var se=class{constructor(e,t){this.AT_TARGET=0,this.BUBBLING_PHASE=0,this.CAPTURING_PHASE=0,this.NONE=0,this.type="",this.srcElement=null,this.currentTarget=null,this.eventPhase=0,this.isTrusted=!0,this.composed=!1,this.cancelable=!0,this.defaultPrevented=!1,this.bubbles=!0,this.lengthComputable=!0,this.loaded=0,this.total=0,this.cancelBubble=!1,this.returnValue=!0,this.type=e,this.target=t?.target||null,this.currentTarget=t?.currentTarget||null,this.timeStamp=Date.now()}composedPath(){return[]}initEvent(e,t,r){this.type=e,this.bubbles=!!t,this.cancelable=!!r}preventDefault(){this.defaultPrevented=!0}stopPropagation(){}stopImmediatePropagation(){}},lt=class extends se{constructor(e,t){super(e),this.lengthComputable=t?.lengthComputable||!1,this.composed=t?.composed||!1,this.loaded=t?.loaded||0,this.total=t?.total||0}},ct=typeof ProgressEvent<"u";function ut(e,t,r){const s=["error","progress","loadstart","loadend","load","timeout","abort"],o=ct?ProgressEvent:lt;return s.includes(t)?new o(t,{lengthComputable:!0,loaded:r?.loaded||0,total:r?.total||0}):new se(t,{target:e,currentTarget:e})}function ne(e,t){if(!(t in e))return null;if(Object.prototype.hasOwnProperty.call(e,t))return e;const s=Reflect.getPrototypeOf(e);return s?ne(s,t):null}function U(e,t){return new Proxy(e,ht(t))}function ht(e){const{constructorCall:t,methodCall:r,getProperty:s,setProperty:o}=e,i={};return typeof t<"u"&&(i.construct=function(n,a,c){const l=Reflect.construct.bind(null,n,a,c);return t.call(c,a,l)}),i.set=function(n,a,c){const l=()=>{const h=ne(n,a)||n,d=Reflect.getOwnPropertyDescriptor(h,a);return typeof d?.set<"u"?(d.set.apply(n,[c]),!0):Reflect.defineProperty(h,a,{writable:!0,enumerable:!0,configurable:!0,value:c})};return typeof o<"u"?o.call(n,[a,c],l):l()},i.get=function(n,a,c){const l=()=>n[a],h=typeof s<"u"?s.call(n,[a,c],l):l();return typeof h=="function"?(...d)=>{const u=h.bind(n,...d);return typeof r<"u"?r.call(n,[a,d],u):u()}:h},i}function dt(e){return["application/xhtml+xml","application/xml","image/svg+xml","text/html","text/xml"].some(r=>e.startsWith(r))}function pt(e){try{return JSON.parse(e)}catch{return null}}function ft(e,t){const r=X(e.status)?null:t;return new Response(r,{status:e.status,statusText:e.statusText,headers:gt(e.getAllResponseHeaders())})}function gt(e){const t=new Headers,r=e.split(/[\r\n]+/);for(const s of r){if(s.trim()==="")continue;const[o,...i]=s.split(": "),n=i.join(": ");t.append(o,n)}return t}var B=Symbol("isMockedResponse"),mt=x(),yt=class{constructor(e,t){this.initialRequest=e,this.logger=t,this.method="GET",this.url=null,this.events=new Map,this.requestId=z(),this.requestHeaders=new Headers,this.responseBuffer=new Uint8Array,this.request=U(e,{setProperty:([r,s],o)=>{switch(r){case"ontimeout":{const i=r.slice(2);return this.request.addEventListener(i,s),o()}default:return o()}},methodCall:([r,s],o)=>{var i;switch(r){case"open":{const[n,a]=s;return typeof a>"u"?(this.method="GET",this.url=$(n)):(this.method=n,this.url=$(a)),this.logger=this.logger.extend(`${this.method} ${this.url.href}`),this.logger.info("open",this.method,this.url.href),o()}case"addEventListener":{const[n,a]=s;return this.registerEvent(n,a),this.logger.info("addEventListener",n,a),o()}case"setRequestHeader":{const[n,a]=s;return this.requestHeaders.set(n,a),this.logger.info("setRequestHeader",n,a),o()}case"send":{const[n]=s;n!=null&&(this.requestBody=typeof n=="string"?He(n):n),this.request.addEventListener("load",()=>{if(typeof this.onResponse<"u"){const l=ft(this.request,this.request.response);this.onResponse.call(this,{response:l,isMockedResponse:B in this.request,request:a,requestId:this.requestId})}});const a=this.toFetchApiRequest();(((i=this.onRequest)==null?void 0:i.call(this,{request:a,requestId:this.requestId}))||Promise.resolve()).finally(()=>{if(this.request.readyState<this.request.LOADING)return this.logger.info("request callback settled but request has not been handled (readystate %d), performing as-is...",this.request.readyState),mt&&this.request.setRequestHeader(Je,this.requestId),o()});break}default:return o()}}})}registerEvent(e,t){const s=(this.events.get(e)||[]).concat(t);this.events.set(e,s),this.logger.info('registered event "%s"',e,t)}respondWith(e){this.logger.info("responding with a mocked response: %d %s",e.status,e.statusText),w(this.request,B,!0),w(this.request,"status",e.status),w(this.request,"statusText",e.statusText),w(this.request,"responseURL",this.url.href),this.request.getResponseHeader=new Proxy(this.request.getResponseHeader,{apply:(s,o,i)=>{if(this.logger.info("getResponseHeader",i[0]),this.request.readyState<this.request.HEADERS_RECEIVED)return this.logger.info("headers not received yet, returning null"),null;const n=e.headers.get(i[0]);return this.logger.info('resolved response header "%s" to',i[0],n),n}}),this.request.getAllResponseHeaders=new Proxy(this.request.getAllResponseHeaders,{apply:()=>{if(this.logger.info("getAllResponseHeaders"),this.request.readyState<this.request.HEADERS_RECEIVED)return this.logger.info("headers not received yet, returning empty string"),"";const o=Array.from(e.headers.entries()).map(([i,n])=>`${i}: ${n}`).join(`\r
`);return this.logger.info("resolved all response headers to",o),o}}),Object.defineProperties(this.request,{response:{enumerable:!0,configurable:!1,get:()=>this.response},responseText:{enumerable:!0,configurable:!1,get:()=>this.responseText},responseXML:{enumerable:!0,configurable:!1,get:()=>this.responseXML}});const t=e.headers.has("Content-Length")?Number(e.headers.get("Content-Length")):void 0;this.logger.info("calculated response body length",t),this.trigger("loadstart",{loaded:0,total:t}),this.setReadyState(this.request.HEADERS_RECEIVED),this.setReadyState(this.request.LOADING);const r=()=>{this.logger.info("finalizing the mocked response..."),this.setReadyState(this.request.DONE),this.trigger("load",{loaded:this.responseBuffer.byteLength,total:t}),this.trigger("loadend",{loaded:this.responseBuffer.byteLength,total:t})};if(e.body){this.logger.info("mocked response has body, streaming...");const s=e.body.getReader(),o=async()=>{const{value:i,done:n}=await s.read();if(n){this.logger.info("response body stream done!"),r();return}i&&(this.logger.info("read response body chunk:",i),this.responseBuffer=at(this.responseBuffer,i),this.trigger("progress",{loaded:this.responseBuffer.byteLength,total:t})),o()};o()}else r()}responseBufferToText(){return _e(this.responseBuffer)}get response(){if(this.logger.info("getResponse (responseType: %s)",this.request.responseType),this.request.readyState!==this.request.DONE)return null;switch(this.request.responseType){case"json":{const e=pt(this.responseBufferToText());return this.logger.info("resolved response JSON",e),e}case"arraybuffer":{const e=Oe(this.responseBuffer);return this.logger.info("resolved response ArrayBuffer",e),e}case"blob":{const e=this.request.getResponseHeader("Content-Type")||"text/plain",t=new Blob([this.responseBufferToText()],{type:e});return this.logger.info("resolved response Blob (mime type: %s)",t,e),t}default:{const e=this.responseBufferToText();return this.logger.info('resolving "%s" response type as text',this.request.responseType,e),e}}}get responseText(){if(v(this.request.responseType===""||this.request.responseType==="text","InvalidStateError: The object is in invalid state."),this.request.readyState!==this.request.LOADING&&this.request.readyState!==this.request.DONE)return"";const e=this.responseBufferToText();return this.logger.info('getResponseText: "%s"',e),e}get responseXML(){if(v(this.request.responseType===""||this.request.responseType==="document","InvalidStateError: The object is in invalid state."),this.request.readyState!==this.request.DONE)return null;const e=this.request.getResponseHeader("Content-Type")||"";return typeof DOMParser>"u"?(console.warn("Cannot retrieve XMLHttpRequest response body as XML: DOMParser is not defined. You are likely using an environment that is not browser or does not polyfill browser globals correctly."),null):dt(e)?new DOMParser().parseFromString(this.responseBufferToText(),e):null}errorWith(e){this.logger.info("responding with an error"),this.setReadyState(this.request.DONE),this.trigger("error"),this.trigger("loadend")}setReadyState(e){if(this.logger.info("setReadyState: %d -> %d",this.request.readyState,e),this.request.readyState===e){this.logger.info("ready state identical, skipping transition...");return}w(this.request,"readyState",e),this.logger.info("set readyState to: %d",e),e!==this.request.UNSENT&&(this.logger.info('triggerring "readystatechange" event...'),this.trigger("readystatechange"))}trigger(e,t){const r=this.request[`on${e}`],s=ut(this.request,e,t);this.logger.info('trigger "%s"',e,t||""),typeof r=="function"&&(this.logger.info('found a direct "%s" callback, calling...',e),r.call(this.request,s));for(const[o,i]of this.events)o===e&&(this.logger.info('found %d listener(s) for "%s" event, calling...',i.length,e),i.forEach(n=>n.call(this.request,s)))}toFetchApiRequest(){this.logger.info("converting request to a Fetch API Request...");const e=new Request(this.url.href,{method:this.method,headers:this.requestHeaders,credentials:this.request.withCredentials?"include":"same-origin",body:["GET","HEAD"].includes(this.method)?null:this.requestBody}),t=U(e.headers,{methodCall:([r,s],o)=>{switch(r){case"append":case"set":{const[i,n]=s;this.request.setRequestHeader(i,n);break}case"delete":{const[i]=s;console.warn(`XMLHttpRequest: Cannot remove a "${i}" header from the Fetch API representation of the "${e.method} ${e.url}" request. XMLHttpRequest headers cannot be removed.`);break}}return o()}});return w(e,"headers",t),this.logger.info("converted request to a Fetch API Request!",e),e}};function $(e){return typeof location>"u"?new URL(e):new URL(e.toString(),location.href)}function w(e,t,r){Reflect.defineProperty(e,t,{writable:!0,enumerable:!0,value:r})}function vt({emitter:e,logger:t}){return new Proxy(globalThis.XMLHttpRequest,{construct(s,o,i){t.info("constructed new XMLHttpRequest");const n=Reflect.construct(s,o,i),a=Object.getOwnPropertyDescriptors(s.prototype);for(const l in a)Reflect.defineProperty(n,l,a[l]);const c=new yt(n,t);return c.onRequest=async function({request:l,requestId:h}){const{interactiveRequest:d,requestController:u}=Z(l);this.logger.info("awaiting mocked response..."),e.once("request",({requestId:m})=>{m===h&&u.responsePromise.state==="pending"&&u.respondWith(void 0)});const f=await M(async()=>{this.logger.info('emitting the "request" event for %s listener(s)...',e.listenerCount("request")),await ee(e,"request",{request:d,requestId:h}),this.logger.info('all "request" listeners settled!');const m=await u.responsePromise;return this.logger.info("event.respondWith called with:",m),m});if(f.error){this.logger.info("request listener threw an exception, aborting request...",f.error),c.errorWith(f.error);return}const g=f.data;if(typeof g<"u"){if(this.logger.info("received mocked response: %d %s",g.status,g.statusText),g.type==="error"){this.logger.info("received a network error response, rejecting the request promise..."),c.errorWith(new TypeError("Network error"));return}return c.respondWith(g)}this.logger.info("no mocked response received, performing request as-is...")},c.onResponse=async function({response:l,isMockedResponse:h,request:d,requestId:u}){this.logger.info('emitting the "response" event for %s listener(s)...',e.listenerCount("response")),e.emit("response",{response:l,isMockedResponse:h,request:d,requestId:u})},c.request}})}var oe=class extends A{constructor(){super(oe.interceptorSymbol)}checkEnvironment(){return typeof globalThis.XMLHttpRequest<"u"}setup(){const e=this.logger.extend("setup");e.info('patching "XMLHttpRequest" module...');const t=globalThis.XMLHttpRequest;v(!t[b],'Failed to patch the "XMLHttpRequest" module: already patched.'),globalThis.XMLHttpRequest=vt({emitter:this.emitter,logger:this.logger}),e.info('native "XMLHttpRequest" module patched!',globalThis.XMLHttpRequest.name),Object.defineProperty(globalThis.XMLHttpRequest,b,{enumerable:!0,configurable:!0,value:!0}),this.subscriptions.push(()=>{Object.defineProperty(globalThis.XMLHttpRequest,b,{value:void 0}),globalThis.XMLHttpRequest=t,e.info('native "XMLHttpRequest" module restored!',globalThis.XMLHttpRequest.name)})}},ie=oe;ie.interceptorSymbol=Symbol("xhr");function wt(e,t){const r=new P({name:"fallback",interceptors:[new re,new ie]});return r.on("request",async({request:s,requestId:o})=>{const i=s.clone(),n=await N(s,o,e.getRequestHandlers(),t,e.emitter,{onMockedResponse(a,{handler:c,parsedResult:l}){t.quiet||e.emitter.once("response:mocked",({response:h})=>{c.log({request:i,response:h,parsedResult:l})})}});n&&s.respondWith(n)}),r.on("response",({response:s,isMockedResponse:o,request:i,requestId:n})=>{e.emitter.emit(o?"response:mocked":"response:bypass",{response:s,request:i,requestId:n})}),r.apply(),r}function bt(e){return async function(r){e.fallbackInterceptor=wt(e,r),G({message:"Mocking enabled (fallback mode).",quiet:r.quiet})}}function Rt(e){return function(){e.fallbackInterceptor?.dispose(),Y({quiet:e.startOptions?.quiet})}}function Et(){try{const e=new ReadableStream({start:r=>r.close()});return new MessageChannel().port1.postMessage(e,[e]),!0}catch{return!1}}var kt=class extends pe{context;startHandler=null;stopHandler=null;listeners;constructor(...e){super(...e),v(!x(),p.formatMessage("Failed to execute `setupWorker` in a non-browser environment. Consider using `setupServer` for Node.js environment instead.")),this.listeners=[],this.context=this.createWorkerContext()}createWorkerContext(){const e={isMockingEnabled:!1,startOptions:null,worker:null,getRequestHandlers:()=>this.handlersController.currentHandlers(),registration:null,requests:new Map,emitter:this.emitter,workerChannel:{on:(t,r)=>{this.context.events.addListener(navigator.serviceWorker,"message",s=>{if(s.source!==this.context.worker)return;const o=s.data;o&&o.type===t&&r(s,o)})},send:t=>{this.context.worker?.postMessage(t)}},events:{addListener:(t,r,s)=>(t.addEventListener(r,s),this.listeners.push({eventType:r,target:t,callback:s}),()=>{t.removeEventListener(r,s)}),removeAllListeners:()=>{for(const{target:t,eventType:r,callback:s}of this.listeners)t.removeEventListener(r,s);this.listeners=[]},once:t=>{const r=[];return new Promise((s,o)=>{const i=n=>{try{const a=n.data;a.type===t&&s(a)}catch(a){o(a)}};r.push(this.context.events.addListener(navigator.serviceWorker,"message",i),this.context.events.addListener(navigator.serviceWorker,"messageerror",o))}).finally(()=>{r.forEach(s=>s())})}},supports:{serviceWorkerApi:!("serviceWorker"in navigator)||location.protocol==="file:",readableStreamTransfer:Et()}};return this.startHandler=e.supports.serviceWorkerApi?bt(e):et(e),this.stopHandler=e.supports.serviceWorkerApi?Rt(e):tt(e),e}async start(e={}){return e.waitUntilReady===!0&&p.warn('The "waitUntilReady" option has been deprecated. Please remove it from this "worker.start()" call. Follow the recommended Browser integration (https://mswjs.io/docs/integrations/browser) to eliminate any race conditions between the Service Worker registration and any requests made by your application on initial render.'),this.context.startOptions=F(rt,e),await this.startHandler(this.context.startOptions,e)}stop(){super.dispose(),this.context.events.removeAllListeners(),this.context.emitter.removeAllListeners(),this.stopHandler()}};function qt(...e){return new kt(...e)}var Lt=/\.(js|jsx|ts|tsx|mjs|woff|woff2|ttf|otf|eot)$/,St=["sb-common-assets","node_modules","node-modules","hot-update.json","__webpack_hmr","sb-vite"],Tt=e=>!!(Lt.test(e)||St.some(r=>e.includes(r))),Pt=e=>typeof e?.onUnhandledRequest=="string"?e:{...e,onUnhandledRequest:(...t)=>{const[{url:r},s]=t;if(!Tt(r)){if(!e?.onUnhandledRequest){s.warning();return}typeof e?.onUnhandledRequest=="function"&&e.onUnhandledRequest(...t)}}},k;function xt(e,t=[]){const r=qt(...t);return r.start(Pt(e)),k=r,r}function Mt(e){for(var t=[],r=1;r<arguments.length;r++)t[r-1]=arguments[r];var s=Array.from(typeof e=="string"?[e]:e);s[s.length-1]=s[s.length-1].replace(/\r?\n([\t ]*)$/,"");var o=s.reduce(function(a,c){var l=c.match(/\n([\t ]+|(?!\s).)/g);return l?a.concat(l.map(function(h){var d,u;return(u=(d=h.match(/[\t ]/g))===null||d===void 0?void 0:d.length)!==null&&u!==void 0?u:0})):a},[]);if(o.length){var i=new RegExp(`
[	 ]{`+Math.min.apply(Math,o)+"}","g");s=s.map(function(a){return a.replace(i,`
`)})}s[0]=s[0].replace(/^\r?\n/,"");var n=s[0];return t.forEach(function(a,c){var l=n.match(/(?:^|\n)( *)$/),h=l?l[1]:"",d=a;typeof a=="string"&&a.includes(`
`)&&(d=String(a).split(`
`).map(function(u,f){return f===0?u:""+h+u}).join(`
`)),n+=d+s[c+1]}),n}function At(e){let t=!1,r;return(...o)=>(t||(t=!0,r=e(...o)),r)}function It(e){return At(()=>{console.warn(Mt(e))})}var Ct=It(`
[msw-storybook-addon] You are using parameters.msw as an Array instead of an Object with a property "handlers". This usage is deprecated and will be removed in the next release. Please use the Object syntax instead.

More info: https://github.com/mswjs/msw-storybook-addon/blob/main/MIGRATION.md#parametersmsw-array-notation-deprecated-in-favor-of-object-notation
`);function Ht(e){if(k?.resetHandlers(),e!=null){if(Array.isArray(e)&&e.length>0){Ct(),k.use(...e);return}if("handlers"in e&&e.handlers){const t=Object.values(e.handlers).filter(Boolean).reduce((r,s)=>r.concat(s),[]);t.length>0&&k.use(...t);return}}}var _t=async e=>(Ht(e.parameters.msw),typeof window<"u"&&"navigator"in window&&navigator.serviceWorker?.controller&&await navigator.serviceWorker.ready,{});xt({onUnhandledRequest:"bypass"});const Wt={parameters:{controls:{matchers:{color:/(background|color)$/i,date:/Date$/i}}},loaders:[_t]};export{Wt as default};
